{
    "1": [
        {
            "description": "숫자형은 정수나 실수를 저장하는 데이터 타입이다. 티베로에서는 ANSI에서 제정한 SQL 표준의 숫자 타입인 NUMBER 타입을 지원한다. NUMBER 타입은 정밀도와 스케일을 함께 정의할 수 있다. 만약 생략될 경우, 가능한 최대 범위와 최대 정밀도 내에서 데이터 값은 지원한다. BINARY FLOAT은 32비트로 저장하는 데이터 타입이다. BINARY DOUBLE은 64비트로 저장하는 2배 정밀도 데이터 타입이다. BINARY FLOAT과 BINARY DOUBLE은 각종 변환함수 및 수학함수를 수행할 수 있는 데이터 타입이다. 티베로에서의 숫자형 우선 순위는 BINARY DOUBLE, BINARY FLOAT, NUMBER 순이다.",
            "keywords": [
                "숫자형",
                "NUMBER",
                "정밀도와 스케일",
                "최대 범위와 최대 정밀도",
                "BINARY FLOAT",
                "BINARY DOUBLE",
                "변환함수 및 수학함수",
                "BINARY DOUBLE, BINARY FLOAT, NUMBER"
            ],
            "questions": [
                "정수나 실수를 저장하는 데이터 타입은 무엇인가?",
                "티베로에서는 어떤 숫자 타입을 지원하는가?",
                "NUMBER 타입에서 무엇을 함께 정의할 수 있는가?",
                "정밀도와 스케일이 생략될 경우 어떤 기준 내에서 데이터 값을 지원하는가?",
                "32비트로 저장하는 데이터 타입은 무엇인가?",
                "64 비트로 저장하는 2배 정밀도 데이터 타입은 무엇인가?",
                "BINARY FLOAT과 BINARY DOUBLE은 무엇을 수행할 수 있는 데이터 타입인가?",
                "티베로에서의 숫자형 우선순위는 어떻게 되는가?"
            ],
            "page_num":1
        },
        {
            "description": "인덱스는 특정 컬럼을 빠르게 검색 할 수 있도록 해주는 데이터 구조이다. 자동 인덱싱은 티베로 모든 테이블의 기본 키 컬럼에 자동으로 생성한다. 인덱스는 한 컬럼에 중복 생성과 복수 컬럼에 단일 생성이 가능하다. 인덱스를 사용할 때와 사용하지 않을 때의 효율을 비교하여 적용할지에 대한 여부는 데이터베이스 시스템에서 자동으로 결정한다.",
            "keywords": [
                "인덱스",
                "자동 인덱싱",
                "중복 생성과 단일 생성",
                "데이터베이스 시스템"
            ],
            "questions": [
                "특정 컬럼을 빠르게 검색 할 수 있도록 해주는 데이터 구조는 무엇인가?",
                "모든 테이블의 기본 키 컬럼에 자동으로 생성되는 것은 무엇인가?",
                "인덱스는 한 컬럼과 복수 컬럼에 무엇이 가능한가?",
                "인덱스를 사용할지 안할지에 대한 효율성 여부는 무엇이 판단하는가?"
            ],
            "page_num": 2
        },
        {
            "description": "티베로의 함수는 단일 로우 함수와 집단 한수로 구분한다. 대부분의 함수는 하나 이상의 파라미터를 입력으로, 하나의 출력을 반환한다. NULL이 입력으로 들어오게 되면 대부분 함수는 NULL을 반환한다. 함수의 변환값 유의. 변환값이 NUMBER인 경우 컬럼의 정밀도와 스케일 범위 내여야 한다. 변환값이 CHAR혹은 VARCHAR인 경우 컬럼의 최대 길이 범위 내여야 한다.",
            "keywords": [
                "단일 로우와 집단",
                "하나의 출력",
                "NULL",
                "정밀도와 스케일",
                "최대 길이"
            ],
            "questions": [
                "티베로의 함수는 무엇으로 구분되는가?",
                "대부분의 함수는 하나 이상의 파라미터를 입력으로 받고 무엇을 반환하는가?",
                "NULL이 입력으로 들어오게 되면 대부분의 함수는 무엇을 반환하는가?",
                "변환값이 NUMBER 타입인 경우 컬럼의 무엇과 무엇의 범위 내여야 하는가?",
                "변환값이 CHAR 타입과 VARCHAR 타입인 경우 컬럼의 어떤 범위 내여야 하는가?"
            ],
            "page_num": 3
        },
        {
            "description": "조인 조건은 서로 다른 두 테이블의 컬럼을 비교하는 WHERE절에서 이루어진다. 세 개 이상의 테이블을 조인하기 위해서는 두 테이블씩 누적으로 결합시킨다. 티베로에서는 최적화기를 통해 효율적으로 테이블 간의 조인 순서를 정한다. ",
            "keywords": [
                "WHERE 절",
                "두 테이블씩 누적",
                "최적화기"
            ],
            "questions": [
                "서로 다른 두 테이블의 컬럼을 비교하는 조인 조건은 어느 절에서 이루어지는가?",
                "세 개 이상의 테이블을 조인하는 방법은?",
                "티베로에서는 테이블 간의 조인 순서는 무엇이 정하는가?"
            ],
            "page_num": 4
        },
        {
            "description": "티베로의 CONNECT BY 절에서는 비교 연산자를 사용할 수 있지만 무한루프에 빠질 위험에는 에러를 반환한다. 하나의 SELECT 절에 CONNECT BY와 WHERE 절이 동시에 존재할 경우 CONNECT BY 먼저 실행 한다. 단, 조인 조건일때는 WHERE 절의 조인 조건을 실행한 후 CONNECT BY 절을 본다. ORDER SIBILINGS BY절은 상하 관계를 유지한 체 정렬한다.",
            "keywords": [
                "CONNECT BY",
                "WHERE",
                "조인 조건",
                "ORDER SIBILINGS BY"
            ],
            "questions": [
                "비교 연산자를 사용할 수 있으며, 무한루프에 빠질 때는 에러를 반환하는 절은?",
                "CONNECT BY와 WHERE가 하나의 SELECT에 동시에 있을 경우 두 번째로 실행되는 절은?",
                "CONNECT BY와 WHERE가 하나의 SELECT에 동시에 있을 경우 WHERE가 먼저 수행 되는 경우는?",
                "상하 관계를 유지한 상태에서 정렬하는 절은?"
            ],
            "page_num": 5
        },
    ]
}